import tkinter as tk
from tkinter import messagebox
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

class DeadlockToolkit:
    def __init__(self, root):  # Fixed method name with double underscores
        self.root = root
        self.root.title("Deadlock Prevention & Recovery Toolkit")
        self.root.geometry("700x500")
        
        tk.Label(root, text="Deadlock Prevention & Recovery Toolkit", font=("Arial", 14, "bold")).pack(pady=10)
        
        self.input_frame = tk.Frame(root)
        self.input_frame.pack(pady=10)
        
        tk.Label(self.input_frame, text="Number of Processes:").grid(row=0, column=0)
        self.num_processes_entry = tk.Entry(self.input_frame)
        self.num_processes_entry.grid(row=0, column=1)
        
        tk.Label(self.input_frame, text="Number of Resources:").grid(row=1, column=0)
        self.num_resources_entry = tk.Entry(self.input_frame)
        self.num_resources_entry.grid(row=1, column=1)
        
        self.process_btn = tk.Button(self.input_frame, text="Set Matrix Inputs", command=self.set_matrices)
        self.process_btn.grid(row=2, columnspan=2, pady=5)
        
        self.detect_btn = tk.Button(root, text="Detect Deadlock", command=self.detect_deadlock)
        self.detect_btn.pack(pady=5)
        
        self.prevent_btn = tk.Button(root, text="Run Banker's Algorithm", command=self.run_bankers_algorithm)
        self.prevent_btn.pack(pady=5)
        
        self.recover_btn = tk.Button(root, text="Recover from Deadlock", command=self.recover_deadlock)
        self.recover_btn.pack(pady=5)
        
        self.graph_btn = tk.Button(root, text="Show Resource Allocation Graph", command=self.show_graph)
        self.graph_btn.pack(pady=5)
        
        self.allocation = None
        self.maximum = None
        self.available = None
        
        # Initialize matrix window attribute
        self.matrix_window = None
        self.allocation_entries = []
        self.maximum_entries = []
        self.available_entry = None
    
    def set_matrices(self):
        try:
            num_processes = int(self.num_processes_entry.get())
            num_resources = int(self.num_resources_entry.get())
            
            if num_processes <= 0 or num_resources <= 0:
                messagebox.showerror("Error", "Number of processes and resources must be positive integers.")
                return
                
            self.allocation = np.zeros((num_processes, num_resources), dtype=int)
            self.maximum = np.zeros((num_processes, num_resources), dtype=int)
            self.available = np.zeros(num_resources, dtype=int)
            
            # Close previous matrix window if it exists
            if self.matrix_window is not None and self.matrix_window.winfo_exists():
                self.matrix_window.destroy()
                
            self.matrix_window = tk.Toplevel(self.root)
            self.matrix_window.title("Enter Matrices")
            
            tk.Label(self.matrix_window, text="Allocation Matrix (comma-separated values per row)").pack()
            self.allocation_entries = []
            for i in range(num_processes):
                entry = tk.Entry(self.matrix_window, width=40)
                entry.pack(pady=2)
                self.allocation_entries.append(entry)
            
            tk.Label(self.matrix_window, text="Maximum Matrix (comma-separated values per row)").pack(pady=5)
            self.maximum_entries = []
            for i in range(num_processes):
                entry = tk.Entry(self.matrix_window, width=40)
                entry.pack(pady=2)
                self.maximum_entries.append(entry)
            
            tk.Label(self.matrix_window, text="Available Resources (comma-separated values)").pack(pady=5)
            self.available_entry = tk.Entry(self.matrix_window, width=40)
            self.available_entry.pack(pady=2)
            
            tk.Button(self.matrix_window, text="Submit", command=self.save_matrices).pack(pady=10)
        except ValueError:
            messagebox.showerror("Error", "Please enter valid numbers for processes and resources.")
    
    def save_matrices(self):
        try:
            num_processes, num_resources = self.allocation.shape
            
            for i, entry in enumerate(self.allocation_entries):
                values = list(map(int, entry.get().split(',')))
                if len(values) != num_resources:
                    raise ValueError(f"Process {i} allocation should have {num_resources} values.")
                self.allocation[i] = values
                
            for i, entry in enumerate(self.maximum_entries):
                values = list(map(int, entry.get().split(',')))
                if len(values) != num_resources:
                    raise ValueError(f"Process {i} maximum should have {num_resources} values.")
                self.maximum[i] = values
                
            available_values = list(map(int, self.available_entry.get().split(',')))
            if len(available_values) != num_resources:
                raise ValueError(f"Available resources should have {num_resources} values.")
            self.available = np.array(available_values)
            
            # Verify that allocation doesn't exceed maximum
            if not np.all(self.allocation <= self.maximum):
                messagebox.showerror("Error", "Allocation cannot exceed maximum claims.")
                return
                
            self.matrix_window.destroy()
            messagebox.showinfo("Success", "Matrices updated successfully!")
        except ValueError as e:
            messagebox.showerror("Error", f"Invalid matrix format: {str(e)}\nUse comma-separated integers.")
    
    def detect_deadlock(self):
        if self.allocation is None or self.maximum is None or self.available is None:
            messagebox.showerror("Error", "Please set matrices first.")
            return
            
        # Calculate need matrix
        need = self.maximum - self.allocation
        
        # Deadlock detection algorithm
        num_processes = len(self.allocation)
        work = self.available.copy()
        finish = np.zeros(num_processes, dtype=bool)
        
        while True:
            found = False
            for i in range(num_processes):
                if not finish[i] and np.all(need[i] <= work):
                    work += self.allocation[i]
                    finish[i] = True
                    found = True
                    break
            if not found:
                break
        
        if np.all(finish):
            messagebox.showinfo("Deadlock Detection", "No deadlock detected.")
        else:
            deadlocked = [i for i in range(num_processes) if not finish[i]]
            messagebox.showwarning("Deadlock Detection", f"Deadlock detected! Processes {deadlocked} are deadlocked.")
    
    def run_bankers_algorithm(self):
        if self.allocation is None or self.maximum is None or self.available is None:
            messagebox.showerror("Error", "Please set matrices first.")
            return
            
        num_processes = len(self.allocation)
        work = self.available.copy()
        finish = np.zeros(num_processes, dtype=bool)
        safe_sequence = []
        
        need = self.maximum - self.allocation
        
        while len(safe_sequence) < num_processes:
            allocated = False
            for i in range(num_processes):
                if not finish[i] and np.all(need[i] <= work):
                    work += self.allocation[i]
                    finish[i] = True
                    safe_sequence.append(i)
                    allocated = True
                    break
            if not allocated:
                messagebox.showwarning("Banker's Algorithm", "Unsafe state detected! Deadlock possible.")
                return
        
        messagebox.showinfo("Banker's Algorithm", f"Safe sequence found: {safe_sequence}")
    
    def recover_deadlock(self):
        if self.allocation is None:
            messagebox.showerror("Error", "Please set matrices first.")
            return
            
        # Detect deadlock first
        num_processes = len(self.allocation)
        need = self.maximum - self.allocation
        work = self.available.copy()
        finish = np.zeros(num_processes, dtype=bool)
        
        while True:
            found = False
            for i in range(num_processes):
                if not finish[i] and np.all(need[i] <= work):
                    work += self.allocation[i]
                    finish[i] = True
                    found = True
                    break
            if not found:
                break
        
        if np.all(finish):
            messagebox.showinfo("Deadlock Recovery", "No deadlock detected. No recovery needed.")
            return
        
        # Find deadlocked processes
        deadlocked = [i for i in range(num_processes) if not finish[i]]
        
        # Choose the least resource-intensive among deadlocked processes
        resource_usage = np.sum(self.allocation[deadlocked], axis=1)
        min_index_local = np.argmin(resource_usage)
        min_index = deadlocked[min_index_local]
        
        # Recover
        self.available += self.allocation[min_index]
        self.allocation[min_index] = np.zeros_like(self.allocation[min_index])
        messagebox.showinfo("Deadlock Recovery", f"Process {min_index} terminated, resources released.")
    
    def show_graph(self):
        if self.allocation is None:
            messagebox.showerror("Error", "Please set matrices first.")
            return
            
        # Create a resource allocation graph based on the allocation matrix
        G = nx.DiGraph()
        
        num_processes, num_resources = self.allocation.shape
        
        # Add nodes
        process_nodes = [f"P{i}" for i in range(num_processes)]
        resource_nodes = [f"R{j}" for j in range(num_resources)]
        
        G.add_nodes_from(process_nodes, bipartite=0)
        G.add_nodes_from(resource_nodes, bipartite=1)
        
        # Add edges based on allocation and need matrices
        need = self.maximum - self.allocation
        
        # Resource allocation edges
        for i in range(num_processes):
            for j in range(num_resources):
                if self.allocation[i, j] > 0:
                    G.add_edge(f"R{j}", f"P{i}", weight=self.allocation[i, j])
                    
        # Resource request edges
        for i in range(num_processes):
            for j in range(num_resources):
                if need[i, j] > 0:
                    G.add_edge(f"P{i}", f"R{j}", weight=need[i, j])
        
        plt.figure(figsize=(10, 8))
        pos = nx.spring_layout(G)
        
        # Draw process nodes
        nx.draw_networkx_nodes(G, pos, nodelist=process_nodes, node_color='lightblue', 
                               node_size=700, label='Processes')
        
        # Draw resource nodes
        nx.draw_networkx_nodes(G, pos, nodelist=resource_nodes, node_color='lightgreen', 
                               node_size=700, label='Resources')
        
        # Draw edges
        nx.draw_networkx_edges(G, pos, edge_color='gray', arrows=True, arrowsize=20)
        
        # Draw labels
        nx.draw_networkx_labels(G, pos, font_size=12)
        
        # Add edge weights
        edge_labels = {(u, v): d['weight'] for u, v, d in G.edges(data=True)}
        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)
        
        plt.title("Resource Allocation Graph")
        plt.legend()
        plt.axis('off')
        plt.tight_layout()
        plt.show()

if __name__ == "__main__":  # Fixed entry point with double underscores
    root = tk.Tk()
    app = DeadlockToolkit(root)
    root.mainloop()
